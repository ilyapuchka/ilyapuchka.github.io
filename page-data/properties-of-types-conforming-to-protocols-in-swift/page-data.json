{"componentChunkName":"component---src-templates-blog-post-js","path":"/properties-of-types-conforming-to-protocols-in-swift/","result":{"data":{"site":{"siteMetadata":{"title":"Ilya Puchka","siteUrl":"https://ilya.puchka.me"}},"markdownRemark":{"id":"e74e6ff6-3719-52e2-bd36-9675a155af90","excerpt":"In Objective-C it's very natural to have a property of type that also conforms to one or few protocols. In Swift that becomes tedious cause you can not simply…","html":"<p>In Objective-C it's very natural to have a property of type that also conforms to one or few protocols. In Swift that becomes tedious cause you can not simply combine types and protocols.</p>\n<p>You can use generics:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">MyOtherType</span> <span class=\"token keyword\">where</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">MyProtocol</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> property<span class=\"token punctuation\">:</span> <span class=\"token class-name\">T</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>But you will notice soon that this approach has more drawbacks then advantages. First if you need to have another such property it will become a mess. Second is that you can not use this type in Interface Builder anymore, as well as you can not see it from Objective-C environment. Third is that interface always looks more complex if there are generics.</p>\n<p>The other way could be to define a protocol that adds some traits of class that you want to extend. Let's say you want to have a <code>UIView</code> property that also conforms to <code>Animatable</code> protocol and you want to access it's animatable trait and view trait. But you don't need to access all of the <code>UIView</code> properties, let's say you need only frame for now. Then you can simply add this property to protocol that extends <code>Animatable</code> protocol, or use protocols composition:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">protocol</span> <span class=\"token class-name\">Animatable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">startAnimating</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">stopAnimating</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protocol</span> <span class=\"token class-name\">AnimatableView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Animatable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> frame<span class=\"token punctuation\">:</span> <span class=\"token class-name\">CGRect</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ViewController</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">UIViewController</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> view<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AnimatableView</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You probably already noticed some problems here too. Every time you will need to access new property of <code>UIView</code> you will need to add it to <code>AnimatableView</code> property. Also you can not pass <code>view</code> property as argument to methods that accept <code>UIView</code>. You can of course force cast it to <code>UIView</code> but <a href=\"http://alisoftware.github.io/swift/2015/09/14/thinking-in-swift-1-addendum/\">pony will be hurt</a> then.</p>\n<p>There is much cleaner yet easy solution:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">protocol</span> <span class=\"token class-name\">Animatable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">startAnimating</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">stopAnimating</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protocol</span> <span class=\"token class-name\">AnyView</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> view<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UIView</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protocol</span> <span class=\"token class-name\">AnimatableView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">AnyView</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Animatable</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//or using protocols composition</span>\n<span class=\"token keyword\">typealias</span> <span class=\"token class-name\">AnimatableView</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">protocol</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">AnyView</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Animatable</span><span class=\"token operator\">></span>\n\n<span class=\"token keyword\">extension</span> <span class=\"token class-name\">UIView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">AnyView</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> view<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UIView</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Instead of having protocol that exposes <em>some</em> properties of <code>UIView</code> we expose the whole <code>UIView</code> type via property and access it when we need to work with instance as with <code>UIView</code>.</p>\n<p>This approach has all advantages of previous one - you can easily access your property by its different traits. But it does not have any of drawbacks of previous solutions. You don't ever need to add any property from <code>UIView</code> class to your protocols if you want to access it. You can use the property in methods that accept <code>UIView</code> simply by passing in its <code>view</code> property. And of course you don't loose Objective-C interoperability and Interface Builder support.</p>\n<p>There are different examples of such approach. For instance Alamofire uses <code>URLRequestConvertible</code> protocol:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">protocol</span> <span class=\"token class-name\">URLRequestConvertible</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> <span class=\"token class-name\">URLRequest</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">NSMutableURLRequest</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">extension</span> <span class=\"token class-name\">NSURLRequest</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">URLRequestConvertible</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">var</span> <span class=\"token class-name\">URLRequest</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">NSMutableURLRequest</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Personally I would not use <code>Convertible</code> name for such protocols cause it doest not mean the same as <code>Convertible</code> protocols in Swift standard library where usually they mean that you can create an instance of protocol type <em>from</em> some other type. For instance you can create <code>StringLiteralConvertible</code> instance <em>from</em> <code>String</code>. Or you can create instance of <code>ArrayLiteralConvertible</code> <em>from</em> array literal. But you can not get array literal back from <code>ArrayLiteralConvertible</code>. So it is conversion only in one direction - <em>from external</em> type <em>to self</em> type. But here we need conversion in other direction - <em>from</em> self type <em>to external</em> type.</p>\n<p>There are though <code>CustromStringConvertible</code> and <code>ConstomDebugStringConvertible</code> that look more like <code>URLRequestConvertible</code> from Alamofire. But for me they are kind of special and I think I liked original <code>Printable</code> name more.</p>\n<p>Personally I would prefer to use names like <code>AnyView</code> or <code>AnyURLRequest</code> or even <code>ViewRepresentable</code> or <code>URLRequestRepresentable</code>. The former is shorter when the latter I think better describes the direction of conversion that happens.</p>","fields":{"slug":"/properties-of-types-conforming-to-protocols-in-swift/"},"frontmatter":{"id":"5b6f5a3a9d28c70f0f015f6e","title":"Properties of types conforming to protocols in Swift","date":"December 25, 2015","description":"In Objective-C it's very natural to have a property of type that also conforms to one or few protocols. In Swift that becomes tedious cause you can not simply combine types and protocols.","tags":""}},"previous":{"excerpt":"Note (15.04.16): This post is updated to reflect some of the latest changes in Dip. In some of my previous posts I wrote about using dependency injection with…","fields":{"slug":"/dependency-injecinjection-with-dip/"},"frontmatter":{"title":"Dependency injection with Dip","date":"December 24, 2015"}},"next":{"excerpt":"TL;DR - You can play with source code and example project here. Storyboards segues are very cool. They are very easy yet powerful. They help to incapsulate…","fields":{"slug":"/intermediate-action-segues/"},"frontmatter":{"title":"Intermediate action segues","date":"December 27, 2015"}}},"pageContext":{"id":"e74e6ff6-3719-52e2-bd36-9675a155af90","previousPostId":"047e148b-f00c-58c4-9a75-9595aca71a5d","nextPostId":"fee58a6f-fcfc-5712-adc6-5f7de0b5a601"}},"staticQueryHashes":["2355076697","2841359383"],"slicesMap":{}}