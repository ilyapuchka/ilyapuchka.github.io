{"componentChunkName":"component---src-templates-blog-post-js","path":"/pattern-matching-vs-range-contains/","result":{"data":{"site":{"siteMetadata":{"title":"Ilya Puchka","siteUrl":"https://ilya.puchka.me"}},"markdownRemark":{"id":"af066e09-100f-51d5-bcf3-fff78cbcff63","excerpt":"Today I was working on simple validators that we use for forms (backed by awesome Eureka) and had to implement validator that validates string length. So I did…","html":"<p>Today I was working on simple validators that we use for forms (backed by awesome <a href=\"https://github.com/xmartlabs/Eureka\">Eureka</a>) and had to implement validator that validates string length. So I did it like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">StringValidator</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Validator</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">typealias</span> <span class=\"token class-name\">ValueType</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span>\n    \n    <span class=\"token keyword\">let</span> stringRange<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Range</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Int</span><span class=\"token operator\">></span>\n    <span class=\"token keyword\">init</span><span class=\"token punctuation\">(</span>stringRange<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Range</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Int</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token operator\">..&lt;</span><span class=\"token class-name\">Int</span><span class=\"token punctuation\">.</span>max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>stringRange <span class=\"token operator\">=</span> stringRange\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">validate</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token operator\">?</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">Bool</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">guard</span> <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> value<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringByTrimmingCharactersInSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token function\">whitespaceAndNewlineCharacterSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> stringRange<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">.</span>characters<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The idea is simple. Form field can have a validator with default range (<code>1..&#x3C;Int.max</code>) that will validate any not empty string, but it can also setup validator with specific range that will define minimum and maximum string length. Using <code>isEmpty</code> on string is not an option because it makes a special case and for that I will need to define a separate validator like <code>NonEmptyStringValidator</code> what looks unnecessary.</p>\n<p>Then I wrote some tests. And noticed that when I pass an empty string as a value and expect that it will fail validation test never completes. First I thought that there is some issues when I combine several validators together. But the reason is much simpler. <code>Range</code> is a <code>SequenceType</code>. And <code>SequenceType</code> provides default implementation for <code>contains(_:)</code> method that simply iterates through all sequence members. Probably <code>Range</code> does not override it so it is iterated from 1 to <code>Int.max</code> and each index is compared with 0. For me it looks strange because I don't see any problem with providing specific implementation of that method that will only check bounds. It will not break the contract of <code>SequenceType</code>. It does not look like <code>Range</code> can contain indexes in random order or can be discontinuous. But for whatever reason we don't have it in stdlib.</p>\n<p>I definitely didn't want to compare range <code>startIndex</code> and <code>endIndex</code> manually. So my first attempt to fix this was moving to <code>NSRange</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">return</span> <span class=\"token class-name\">NSLocationInRange</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">.</span>characters<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">,</span> <span class=\"token class-name\">NSRange</span><span class=\"token punctuation\">(</span>stringRange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>It works and only checks for range bounds. But that does not look nice either.</p>\n<p>After some time I found much better solution (I think it dawned on me at the moment when I switched to Safari tab with <a href=\"https://appventure.me/2015/08/20/swift-pattern-matching-in-detail/\">\"Match me if you can\"</a> article):</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">return</span> stringRange <span class=\"token operator\">~=</span> value<span class=\"token punctuation\">.</span>characters<span class=\"token punctuation\">.</span>count</code></pre></div>\n<p>Works perfectly and looks much better than any other solution. Though I had to put a comment describing what it does because <code>~=</code> is so rarely used by itself.</p>\n<blockquote>\n<p>Also I found out that there are <code>HalfOpenInterval</code> and <code>ClosedInterval</code> that are returned from <code>...</code> or <code>..&#x3C;</code> operators for <code>Comparable</code> generic argument. But for <code>ForwardIndexType</code> (which <code>Int</code> is) these operators return <code>Range</code>. Intervals are not collections or sequences and don't have aforementioned issue.</p>\n</blockquote>","fields":{"slug":"/pattern-matching-vs-range-contains/"},"frontmatter":{"id":"5b6f5a3a9d28c70f0f015f72","title":"~= vs Range.contains(_:)","date":"April 14, 2016","description":"Today I was working on simple validators that we use for forms (backed by awesome Eureka) and had to implement validator that validates string length. So I did it like this...","tags":"Swift"}},"previous":{"excerpt":"I definitely agree with those who say that you should not depend on code from external source (meaning where and how it is hosted). You should check in any code…","fields":{"slug":"/on-package-managers/"},"frontmatter":{"title":"On package managers","date":"March 29, 2016"}},"next":{"excerpt":"There were few times already when I used this little-known feature of Swift in real code and it improved (in my opinion) readability a lot and much better…","fields":{"slug":"/mixing-optional-binding-and-boolean-expressions/"},"frontmatter":{"title":"Mixing optional binding and boolean expressions","date":"April 28, 2016"}}},"pageContext":{"id":"af066e09-100f-51d5-bcf3-fff78cbcff63","previousPostId":"5f1bcd95-a64f-5dca-956f-b99a1d092769","nextPostId":"abc40eff-73e0-597e-bf2c-2336572c9442"}},"staticQueryHashes":["2355076697","2841359383"],"slicesMap":{}}