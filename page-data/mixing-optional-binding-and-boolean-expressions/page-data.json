{"componentChunkName":"component---src-templates-blog-post-js","path":"/mixing-optional-binding-and-boolean-expressions/","result":{"data":{"site":{"siteMetadata":{"title":"Ilya Puchka","siteUrl":"https://ilya.puchka.me"}},"markdownRemark":{"id":"abc40eff-73e0-597e-bf2c-2336572c9442","excerpt":"There were few times already when I used this little-known feature of Swift in real code and it improved (in my opinion) readability a lot and much better…","html":"<p>There were few times already when I used this little-known feature of Swift in real code and it improved (in my opinion) readability a lot and much better described the intention of the code.</p>\n<p>Here is the original code from the real app:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">if</span> <span class=\"token keyword\">let</span> cutoffDate <span class=\"token operator\">=</span> menu<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>cutoffDate <span class=\"token keyword\">where</span> menu<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>mealSwapEnabledForProduct <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Very trivial piece of code. But it contains one problem - it communicate wrong intention. When optional binding comes first and is followed by <code>where</code> it may seem that we make decision based on the value in this optional and the boolean expression is secondary. But in fact decision here should be made based on the boolean expression.</p>\n<p>We can make it much better because we don't have to have <code>where</code> always at the end of <code>if</code> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">if</span> menu<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>mealSwapEnabledForProduct <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">let</span> cutoffDate <span class=\"token operator\">=</span> menu<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>cutoffDate <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I think this way the code communicates our logic and intention much better.</p>\n<p>In Swift we can combine optional binding with <code>where</code> and boolean expressions. But after we started optional binding block we can have only <code>where</code> at the end of it, or another optional binding block with its own <code>where</code>. So boolean expression can not appear after optional binding.</p>\n<p>Here is the full <a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-head\">grammar</a> of <code>if</code> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if-statement → if­ condition-clause ­code-block­ else-clause(opt­)\nelse-clause → else­ code-block­ else­ if-statement­\n\ncondition-clause → expression­\ncondition-clause → expression­,­ condition-list­\ncondition-clause → condition-list­\ncondition-clause → availability-condition­, ­expression­\ncondition-list → condition­ | condition­,­ condition-list­\ncondition → availability-condition­ | case-condition­ | optional-binding-condition­\ncase-condition → case ­pattern­ initializer­ where-clause(­opt)­\noptional-binding-condition → optional-binding-head­ optional-binding-continuation-list­(opt) ­where-clause­opt­\noptional-binding-head → let­ pattern­ initializer­ | var ­pattern initializer­\noptional-binding-continuation-list → optional-binding-continuation­ | optional-binding-continuation­, ­optional-binding-continuation-list­\noptional-binding-continuation → pattern ­initializer­ | optional-binding-head­</code></pre></div>\n<p>So this grammar says that condition can start with expression (boolean) or availability condition, followed by condition list, which can contain another availability condition or <code>case</code> condition or optional binding. And as you can see condition list can contain several other condition lists.</p>\n<p>For example this is a valid <code>if</code> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">if</span>\n  <span class=\"token other-directive property\">#available</span><span class=\"token punctuation\">(</span>watchOS <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n  booleanExpr1 <span class=\"token operator\">&amp;&amp;</span> booleanExpr2<span class=\"token punctuation\">,</span> \n  <span class=\"token other-directive property\">#available</span><span class=\"token punctuation\">(</span>iOS <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n  <span class=\"token keyword\">let</span> value11 <span class=\"token operator\">=</span> value1 <span class=\"token keyword\">where</span> value11 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">case</span> <span class=\"token keyword\">let</span> <span class=\"token punctuation\">.</span><span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> value1 <span class=\"token keyword\">where</span> value1 <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token other-directive property\">#available</span><span class=\"token punctuation\">(</span><span class=\"token constant\">OSX</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n  <span class=\"token keyword\">case</span> <span class=\"token keyword\">let</span> <span class=\"token punctuation\">.</span><span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> value2 <span class=\"token keyword\">where</span> value2 <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">let</span> value22 <span class=\"token operator\">=</span> value2 <span class=\"token keyword\">where</span> value22 <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span></code></pre></div>","fields":{"slug":"/mixing-optional-binding-and-boolean-expressions/"},"frontmatter":{"id":"5b6f5a3a9d28c70f0f015f73","title":"Mixing optional binding and boolean expressions","date":"April 28, 2016","description":"There were few times already when I used this little-known feature of Swift in real code and it improved (in my opinion) readability a lot and much better described the intention of the code.","tags":"Swift"}},"previous":{"excerpt":"Today I was working on simple validators that we use for forms (backed by awesome Eureka) and had to implement validator that validates string length. So I did…","fields":{"slug":"/pattern-matching-vs-range-contains/"},"frontmatter":{"title":"~= vs Range.contains(_:)","date":"April 14, 2016"}},"next":{"excerpt":"This post is a script of the talk that I've made on UIKonf'16. That was a first time for me to present on such a big conference and honestly I'm not even close…","fields":{"slug":"/dependency-injection-in-swift/"},"frontmatter":{"title":"Dependency Injection (DI) in Swift","date":"May 28, 2016"}}},"pageContext":{"id":"abc40eff-73e0-597e-bf2c-2336572c9442","previousPostId":"af066e09-100f-51d5-bcf3-fff78cbcff63","nextPostId":"bd0fcddb-010d-5823-b92f-cf794ee57a51"}},"staticQueryHashes":["2355076697","2841359383"],"slicesMap":{}}