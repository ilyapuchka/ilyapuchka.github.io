{"componentChunkName":"component---src-templates-blog-post-js","path":"/douglas-peucker-algorithm/","result":{"data":{"site":{"siteMetadata":{"title":"Ilya Puchka","siteUrl":"https://ilya.puchka.me"}},"markdownRemark":{"id":"401de896-e85f-50ef-aede-db6dc97e9774","excerpt":"This post is a part of the series about shapes recognition. This post is also available as a part of a playground. When drawing by hand, especially in a slow…","html":"<blockquote>\n<p>This post is a part of the <a href=\"http://ilya.puchka.me/shapes-recognition/\">series about shapes recognition</a>. This post is also available as a part of a <a href=\"https://github.com/ilyapuchka/ShapesRecognition\">playground</a>.</p>\n</blockquote>\n<p>When drawing by hand, especially in a slow manner, we will get a lot of touch points and the resulting curve will contain lots of close points. Also we can not draw ideally, so resulting curve can contain artifacts like hooklet at the end of the curve, closed shapes can not be ideally closed. These artifacts are insignificant for recognizing a shape and only complicate calculations. To eliminate deviation from \"ideal\" curve there are different preprocessing algorithms that we can apply before proceeding to the next steps of shape recognition.</p>\n<h3>Douglas-Peucker algorithm</h3>\n<p>When implementing smooth freehand drawing we were making our curve more complex by transforming line segments to Bezier curves. Now we will do opposite procedure - we will simplify our curve by removing insignificant points. Douglas-Peucker algorithm is one of the tools to solve that problem.</p>\n<blockquote>\n<p><em>The purpose of the algorithm is, given a curve composed of line segments, to find a similar curve with fewer points. The algorithm defines 'dissimilar' based on the maximum distance between the original curve and the simplified curve (i.e., the Hausdorff distance between the curves). The simplified curve consists of a subset of the points that defined the original curve.</em><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n</blockquote>\n<p>The input of the algorithm is a curve represented by an ordered set of points (<em>P1</em>,...,<em>Pn</em>) and the threshold ℇ > 0. The output is the curve represented by the subset of the input set of points.</p>\n<p>On the first step of the algorithm we search for the farthest point (<em>Pz</em>) from the line segment between the start and the end points (<em>P1</em> and <em>Pn</em>). If that point is closer than the threshold (ℇ) all the points between <em>P1</em> and <em>Pn</em> are discarded. Otherwise the <em>Pz</em> is included in the resulting set. Then we repeat the same step recursively with the right and the left parts of the curve (from <em>P1</em> to <em>Pz</em> and from <em>Pz</em> to <em>Pn</em>). Then we merge the results of processing the left and the right parts. Algorithm repeats until all the points are handled.</p>\n<blockquote>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/3/30/Douglas-Peucker_animated.gif\" alt=\"\"></p>\n</blockquote>\n<blockquote>\n<p><em>Simplifying a piecewise linear curve with the Douglas–Peucker algorithm.</em><sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n</blockquote>\n<p>First let's write a helper function that will find the farthest point.</p>\n<blockquote>\n<p>For brevity I don't include functions that are used to calculate the distance between the point and the line segment. They are pretty trivial geometric calculations and you can find them in the source files for this playground.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\">    <span class=\"token keyword\">typealias</span> <span class=\"token class-name\">FarthestPoint</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span><span class=\"token punctuation\">,</span> point<span class=\"token punctuation\">:</span> <span class=\"token class-name\">CGPoint</span><span class=\"token operator\">!</span><span class=\"token punctuation\">,</span> distance<span class=\"token punctuation\">:</span> <span class=\"token class-name\">CGFloat</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">farthestPoint</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">CGPoint</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">FarthestPoint</span><span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> farthest<span class=\"token punctuation\">:</span> <span class=\"token class-name\">FarthestPoint</span><span class=\"token operator\">?</span>\n    \n    <span class=\"token comment\">//if there are less then two points in the set return nil</span>\n    <span class=\"token keyword\">guard</span> points<span class=\"token punctuation\">.</span>count <span class=\"token operator\">>=</span> <span class=\"token number\">3</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> farthest <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">,</span> pn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">.</span>first<span class=\"token operator\">!</span><span class=\"token punctuation\">,</span> points<span class=\"token punctuation\">.</span>last<span class=\"token operator\">!</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token comment\">//find the farthest point from the line segment between the start and the end points</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..&lt;</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">.</span>count <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> distance <span class=\"token operator\">=</span> points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">distance</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">,</span> pn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> distance <span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>farthest<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>distance <span class=\"token operator\">??</span> <span class=\"token operator\">-</span><span class=\"token class-name\">CGFloat</span><span class=\"token punctuation\">.</span>max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            farthest <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> distance<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> farthest\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>With that function it is trivial to implement the algorithm.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\">     <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">douglasPeucker</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">CGPoint</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> tolerance<span class=\"token punctuation\">:</span> <span class=\"token class-name\">CGFloat</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">CGPoint</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//if the farthest point can not be found include all points from the input set</span>\n        <span class=\"token keyword\">guard</span> <span class=\"token keyword\">let</span> farthest <span class=\"token operator\">=</span> <span class=\"token function\">farthestPoint</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token keyword\">return</span> points \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">//if the farthest point is closer than a threshold only include the start and the end points of the input set</span>\n        <span class=\"token keyword\">guard</span> farthest<span class=\"token punctuation\">.</span>distance <span class=\"token operator\">></span> tolerance <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>points<span class=\"token punctuation\">.</span>first<span class=\"token operator\">!</span><span class=\"token punctuation\">,</span> points<span class=\"token punctuation\">.</span>last<span class=\"token operator\">!</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n     \n        <span class=\"token comment\">//Otherwise recursively apply the algorithm to the left and to the right parts of the set</span>\n        <span class=\"token keyword\">let</span> <span class=\"token keyword\">left</span> <span class=\"token operator\">=</span> <span class=\"token function\">douglasPeucker</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">...</span>farthest<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> tolerance<span class=\"token punctuation\">:</span> tolerance<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">let</span> <span class=\"token keyword\">right</span> <span class=\"token operator\">=</span> <span class=\"token function\">douglasPeucker</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">[</span>farthest<span class=\"token punctuation\">.</span>index<span class=\"token operator\">..&lt;</span>points<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> tolerance<span class=\"token punctuation\">:</span> tolerance<span class=\"token punctuation\">)</span>\n     \n        <span class=\"token comment\">//Now merge left and right parts removing duplicated point</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">left</span><span class=\"token punctuation\">.</span><span class=\"token function\">dropLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">right</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Let's see how this algorithm works on a sample set of points.<br>\nFirst here is the input path built by connecting each sample point with line segments:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 567px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e8056d4cf3ffb49556fb12f052d83a69/8710b/Input-curve.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.486486486486484%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAArUlEQVR42qVQyw7DIAzr/3/mDtMqdZRXSbJN8pQSBOra0w4WxDiOyXRbBC4ylvAfnoExe8E0e8ZHCMwEMbyk36/ARCCyOxPeQoiZMT1W3sliglIIIfWGQv2t1WoQcwUPXDgzVEHIFWxCHgy11qEu/A7xZ4bN1CeCizVF3nr6lCuv3HHQnlB3qDsj20VLJNwNkiVu31ReBr32ipjhfRXEjfe4R6gg2jly4UK7RMEXw+Qd7QCUs+sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Input curve\"\n        title=\"\"\n        src=\"/static/e8056d4cf3ffb49556fb12f052d83a69/8710b/Input-curve.png\"\n        srcset=\"/static/e8056d4cf3ffb49556fb12f052d83a69/12f09/Input-curve.png 148w,\n/static/e8056d4cf3ffb49556fb12f052d83a69/e4a3f/Input-curve.png 295w,\n/static/e8056d4cf3ffb49556fb12f052d83a69/8710b/Input-curve.png 567w\"\n        sizes=\"(max-width: 567px) 100vw, 567px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Here is the resulting path with threshold value of 5. You can play with it and see how higher values will discard more points.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 565px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/08e6a7e7463fefbf8cf5923c484682e0/07eba/Output-curve.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.13513513513513%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAApklEQVR42qWRyQ7CMAxE+/8fibi1qYRcstlBSAOuG5puJw5PSryMrXF3c4JxEvQkGP6kp4LOEeNdGMKMIsZL1vcVWs9Ljyw9MQu6gSyYsxWkzHgGe+elqWWOCYOC1da4DvDpRFATKqjUTTYIIzGD/HbQUXC3yRSsKURGTCs+Mh6ekdKF4JmH1UctVEHfoKJy4unPw/toV9YruYb5P1muxVXoyPC98gehHRyYytKv3wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Output curve\"\n        title=\"\"\n        src=\"/static/08e6a7e7463fefbf8cf5923c484682e0/07eba/Output-curve.png\"\n        srcset=\"/static/08e6a7e7463fefbf8cf5923c484682e0/12f09/Output-curve.png 148w,\n/static/08e6a7e7463fefbf8cf5923c484682e0/e4a3f/Output-curve.png 295w,\n/static/08e6a7e7463fefbf8cf5923c484682e0/07eba/Output-curve.png 565w\"\n        sizes=\"(max-width: 565px) 100vw, 565px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Here you can see how each step of the algorithm performs. The farthest point on the each step is marked with a square. Points discarded on a previous step are drawn with a cross.</p>\n<p><img src=\"/images/douglas-peucker-iterations.gif\" alt=\"\"></p>\n<p>The algorithm can be implemented without recursion but I will leave it for you as an exercise.</p>\n<blockquote>\n<p>Hint: Usually recursion can be replaced by using stacks.</p>\n</blockquote>\n<hr>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\">https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://upload.wikimedia.org/wikipedia/commons/3/30/Douglas-Peucker_animated.gif\">https://upload.wikimedia.org/wikipedia/commons/3/30/Douglas-Peucker_animated.gif</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","fields":{"slug":"/douglas-peucker-algorithm/"},"frontmatter":{"id":"5b6f5a3a9d28c70f0f015f78","title":"Douglas-Peucker algorithm","date":"August 13, 2016","description":"When drawing by hand, especially in a slow manner, we will get a lot of touch points and the resulting curve will contain lots of close points. Also we can not draw ideally, so resulting curve can contain artifacts like hooklet at the end of the curve, closed shapes can not be ideally closed. These artifacts are insignificant for recognizing a shape and only complicate calculations. To eliminate deviation from \"ideal\" curve there are different preprocessing algorithms that we can apply before proceeding to the next steps of shape recognition.","tags":""}},"previous":{"excerpt":"This post is a part of the series about shapes recognition. This post is also available as a part of a playground. Naive implementation of rendering user's…","fields":{"slug":"/freehand-drawing/"},"frontmatter":{"title":"Freehand drawing","date":"July 31, 2016"}},"next":{"excerpt":"Recently I came across an article by Max Howell describing how he had setup PromiseKit project to use just a single target instead of a separate target for each…","fields":{"slug":"/xcode-cross-platform-frameworks/"},"frontmatter":{"title":"Xcode & cross-platform frameworks","date":"August 18, 2016"}}},"pageContext":{"id":"401de896-e85f-50ef-aede-db6dc97e9774","previousPostId":"23687732-a611-5480-8d77-96ef06cc90cd","nextPostId":"181828f3-3df0-559d-96b3-4dc55c45077e"}},"staticQueryHashes":["2355076697","2841359383"],"slicesMap":{}}